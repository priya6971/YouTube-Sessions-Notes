1. Insert into BST
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None:
            return TreeNode(val)
        else:
            if root.val < val:
                root.right = self.insertIntoBST(root.right, val)
            else:
                root.left = self.insertIntoBST(root.left, val)
        return root


2. Search in BST

class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None or root.val == val:
            return root

        elif val < root.val:
            return self.searchBST(root.left, val)
        
        else:
            return self.searchBST(root.right, val)



3. Deletion in BST
class Solution:
    # Right subtree - minimum value
    def successor(self, root):
        root = root.right
        while root.left is not None:
            root = root.left
        return root.val

    # Left subtree - maximum value
    def predecessor(self, root):
        root = root.left
        while root.right is not None:
            root = root.right
        return root.val

    def deleteNode(self, root, key):
        # Base case condition
        if root is None:
            return None

        # 1. Search the node to be deleted
        if key > root.val:
            # Traverse towards the right subtree
            root.right = self.deleteNode(root.right, key)
        elif key < root.val:
            # Traverse towards the left subtree
            root.left = self.deleteNode(root.left, key)
        else:
            # Case 1: Leaf Node
            if root.left is None and root.right is None:
                root = None
            # Case 2: Non-leaf node
            elif root.right is not None:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right, root.val)
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left, root.val)

        return root


4. Validation of BST

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def inorderTraversal(self, node):
        if node.left:
            self.inorderTraversal(node.left)
        
        self.res.append(node.val)
        
        if node.right:
            self.inorderTraversal(node.right)
    
    def isValidBST(self, root: TreeNode) -> bool:
        if root is None:
            return
        
        self.res = []
        self.inorderTraversal(root)
        
        n = len(self.res)
        
        ## List is sorted or not
        ## Sorted : validBST -> True
        ## Not Sorted : notvalidBST -> False
        for i in range(n-1):
            if self.res[i] >= self.res[i+1]:
                return False
        
        return True

5. Kth Smallest Element

class Solution:
    def inOrderTraversal(self, node):
        if node.left:
            self.inOrderTraversal(node.left)
        
        self.res.append(node.val)

        if node.right:
            self.inOrderTraversal(node.right)

    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        if root is None:
            return 
        
        self.res = []
        self.inOrderTraversal(root)

        return self.res[k-1]
        